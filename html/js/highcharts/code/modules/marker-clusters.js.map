{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v12.1.2 (2025-01-09)\n * @module highcharts/modules/marker-clusters\n * @requires highcharts\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2024 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(root[\"_Highcharts\"]);\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"highcharts/modules/marker-clusters\", [\"highcharts/highcharts\"], function (amd1) {return factory(amd1);});\n\telse if(typeof exports === 'object')\n\t\texports[\"highcharts/modules/marker-clusters\"] = factory(root[\"_Highcharts\"]);\n\telse\n\t\troot[\"Highcharts\"] = factory(root[\"Highcharts\"]);\n})(typeof window === 'undefined' ? this : window, (__WEBPACK_EXTERNAL_MODULE__944__) => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 944:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__944__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ marker_clusters_src)\n});\n\n// EXTERNAL MODULE: external {\"amd\":[\"highcharts/highcharts\"],\"commonjs\":[\"highcharts\"],\"commonjs2\":[\"highcharts\"],\"root\":[\"Highcharts\"]}\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_ = __webpack_require__(944);\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default = /*#__PURE__*/__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);\n;// ./code/es-modules/Extensions/MarkerClusters/MarkerClusterDefaults.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2024 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Options for marker clusters, the concept of sampling the data\n * values into larger blocks in order to ease readability and\n * increase performance of the JavaScript charts.\n *\n * Note: marker clusters module is not working with `boost`\n * and `draggable-points` modules.\n *\n * The marker clusters feature requires the marker-clusters.js\n * file to be loaded, found in the modules directory of the download\n * package, or online at [code.highcharts.com/modules/marker-clusters.js\n * ](code.highcharts.com/modules/marker-clusters.js).\n *\n * @sample maps/marker-clusters/europe\n *         Maps marker clusters\n * @sample highcharts/marker-clusters/basic\n *         Scatter marker clusters\n * @sample maps/marker-clusters/optimized-kmeans\n *         Marker clusters with colorAxis\n *\n * @product      highcharts highmaps\n * @since 8.0.0\n * @optionparent plotOptions.scatter.cluster\n *\n * @private\n */\nconst cluster = {\n    /**\n     * Whether to enable the marker-clusters module.\n     *\n     * @sample maps/marker-clusters/basic\n     *         Maps marker clusters\n     * @sample highcharts/marker-clusters/basic\n     *         Scatter marker clusters\n     */\n    enabled: false,\n    /**\n     * When set to `false` prevent cluster overlapping - this option\n     * works only when `layoutAlgorithm.type = \"grid\"`.\n     *\n     * @sample highcharts/marker-clusters/grid\n     *         Prevent overlapping\n     */\n    allowOverlap: true,\n    /**\n     * Options for the cluster marker animation.\n     * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n     * @default { \"duration\": 500 }\n     */\n    animation: {\n        /** @ignore-option */\n        duration: 500\n    },\n    /**\n     * Zoom the plot area to the cluster points range when a cluster is clicked.\n     */\n    drillToCluster: true,\n    /**\n     * The minimum amount of points to be combined into a cluster.\n     * This value has to be greater or equal to 2.\n     *\n     * @sample highcharts/marker-clusters/basic\n     *         At least three points in the cluster\n     */\n    minimumClusterSize: 2,\n    /**\n     * Options for layout algorithm. Inside there\n     * are options to change the type of the algorithm, gridSize,\n     * distance or iterations.\n     */\n    layoutAlgorithm: {\n        /**\n         * Type of the algorithm used to combine points into a cluster.\n         * There are three available algorithms:\n         *\n         * 1) `grid` - grid-based clustering technique. Points are assigned\n         * to squares of set size depending on their position on the plot\n         * area. Points inside the grid square are combined into a cluster.\n         * The grid size can be controlled by `gridSize` property\n         * (grid size changes at certain zoom levels).\n         *\n         * 2) `kmeans` - based on K-Means clustering technique. In the\n         * first step, points are divided using the grid method (distance\n         * property is a grid size) to find the initial amount of clusters.\n         * Next, each point is classified by computing the distance between\n         * each cluster center and that point. When the closest cluster\n         * distance is lower than distance property set by a user the point\n         * is added to this cluster otherwise is classified as `noise`. The\n         * algorithm is repeated until each cluster center not change its\n         * previous position more than one pixel. This technique is more\n         * accurate but also more time consuming than the `grid` algorithm,\n         * especially for big datasets.\n         *\n         * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n         * algorithm uses k-means algorithm only on the chart initialization\n         * or when chart extremes have greater range than on initialization.\n         * When a chart is redrawn the algorithm checks only clustered points\n         * distance from the cluster center and rebuild it when the point is\n         * spaced enough to be outside the cluster. It provides performance\n         * improvement and more stable clusters position yet can be used rather\n         * on small and sparse datasets.\n         *\n         * By default, the algorithm depends on visible quantity of points\n         * and `kmeansThreshold`. When there are more visible points than the\n         * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n         *\n         * The custom clustering algorithm can be added by assigning a callback\n         * function as the type property. This function takes an array of\n         * `processedXData`, `processedYData`, `processedXData` indexes and\n         * `layoutAlgorithm` options as arguments and should return an object\n         * with grouped data.\n         *\n         * The algorithm should return an object like that:\n         * <pre>{\n         *  clusterId1: [{\n         *      x: 573,\n         *      y: 285,\n         *      index: 1 // point index in the data array\n         *  }, {\n         *      x: 521,\n         *      y: 197,\n         *      index: 2\n         *  }],\n         *  clusterId2: [{\n         *      ...\n         *  }]\n         *  ...\n         * }</pre>\n         *\n         * `clusterId` (example above - unique id of a cluster or noise)\n         * is an array of points belonging to a cluster. If the\n         * array has only one point or fewer points than set in\n         * `cluster.minimumClusterSize` it won't be combined into a cluster.\n         *\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Optimized K-Means algorithm\n         * @sample highcharts/marker-clusters/kmeans\n         *         K-Means algorithm\n         * @sample highcharts/marker-clusters/grid\n         *         Grid algorithm\n         * @sample maps/marker-clusters/custom-alg\n         *         Custom algorithm\n         *\n         * @type {string|Function}\n         * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n         * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n         */\n        /**\n         * When `type` is set to the `grid`,\n         * `gridSize` is a size of a grid square element either as a number\n         * defining pixels, or a percentage defining a percentage\n         * of the plot area width.\n         *\n         * @type    {number|string}\n         */\n        gridSize: 50,\n        /**\n         * When `type` is set to `kmeans`,\n         * `iterations` are the number of iterations that this algorithm will be\n         * repeated to find clusters positions.\n         *\n         * @type    {number}\n         * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n         */\n        /**\n         * When `type` is set to `kmeans`,\n         * `distance` is a maximum distance between point and cluster center\n         * so that this point will be inside the cluster. The distance\n         * is either a number defining pixels or a percentage\n         * defining a percentage of the plot area width.\n         *\n         * @type    {number|string}\n         */\n        distance: 40,\n        /**\n         * When `type` is set to `undefined` and there are more visible points\n         * than the kmeansThreshold the `grid` algorithm is used to find\n         * clusters, otherwise `kmeans`. It ensures good performance on\n         * large datasets and better clusters arrangement after the zoom.\n         */\n        kmeansThreshold: 100\n    },\n    /**\n     * Options for the cluster marker.\n     * @type      {Highcharts.PointMarkerOptionsObject}\n     * @extends   plotOptions.series.marker\n     * @excluding enabledThreshold, states\n     */\n    marker: {\n        /** @internal */\n        symbol: 'cluster',\n        /** @internal */\n        radius: 15,\n        /** @internal */\n        lineWidth: 0,\n        /** @internal */\n        lineColor: \"#ffffff\" /* Palette.backgroundColor */\n    },\n    /**\n     * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n     * One parameter, `event`, is passed to the function. The default action\n     * is to zoom to the cluster points range. This can be prevented\n     * by calling `event.preventDefault()`.\n     *\n     * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n     * @product   highcharts highmaps\n     * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n     * @apioption plotOptions.scatter.cluster.events.drillToCluster\n     */\n    /**\n     * An array defining zones within marker clusters.\n     *\n     * In styled mode, the color zones are styled with the\n     * `.highcharts-cluster-zone-{n}` class, or custom\n     * classed from the `className`\n     * option.\n     *\n     * @sample highcharts/marker-clusters/basic\n     *         Marker clusters zones\n     * @sample maps/marker-clusters/custom-alg\n     *         Zones on maps\n     *\n     * @type      {Array<*>}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones\n     */\n    /**\n     * Styled mode only. A custom class name for the zone.\n     *\n     * @sample highcharts/css/color-zones/\n     *         Zones styled by class name\n     *\n     * @type      {string}\n     * @apioption plotOptions.scatter.cluster.zones.className\n     */\n    /**\n     * Settings for the cluster marker belonging to the zone.\n     *\n     * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n     * @extends   plotOptions.scatter.cluster.marker\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.marker\n     */\n    /**\n     * The value where the zone starts.\n     *\n     * @type      {number}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.from\n     */\n    /**\n     * The value where the zone ends.\n     *\n     * @type      {number}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.to\n     */\n    /**\n     * The fill color of the cluster marker in hover state. When\n     * `undefined`, the series' or point's fillColor for normal\n     * state is used.\n     *\n     * @type      {Highcharts.ColorType}\n     * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n     */\n    /**\n     * Options for the cluster data labels.\n     * @type    {Highcharts.DataLabelsOptions}\n     */\n    dataLabels: {\n        /** @internal */\n        enabled: true,\n        /** @internal */\n        format: '{point.clusterPointsAmount}',\n        /** @internal */\n        verticalAlign: 'middle',\n        /** @internal */\n        align: 'center',\n        /** @internal */\n        style: {\n            color: 'contrast'\n        },\n        /** @internal */\n        inside: true\n    }\n};\nconst tooltip = {\n    /**\n     * The HTML of the cluster point's in the tooltip. Works only with\n     * marker-clusters module and analogously to\n     * [pointFormat](#tooltip.pointFormat).\n     *\n     * The cluster tooltip can be also formatted using\n     * `tooltip.formatter` callback function and `point.isCluster` flag.\n     *\n     * @sample highcharts/marker-clusters/grid\n     *         Format tooltip for cluster points.\n     *\n     * @sample maps/marker-clusters/europe/\n     *         Format tooltip for clusters using tooltip.formatter\n     *\n     * @type      {string}\n     * @default   Clustered points: {point.clusterPointsAmount}\n     * @apioption tooltip.clusterFormat\n     */\n    clusterFormat: '<span>Clustered points: ' +\n        '{point.clusterPointsAmount}</span><br/>'\n};\n/* *\n *\n *  Default Export\n *\n * */\nconst MarkerClusterDefaults = {\n    cluster,\n    tooltip\n};\n/* harmony default export */ const MarkerClusters_MarkerClusterDefaults = (MarkerClusterDefaults);\n\n;// ./code/es-modules/Data/DataTableCore.js\n/* *\n *\n *  (c) 2009-2024 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Gøran Slettemark\n *  - Torstein Hønsi\n *\n * */\n\n\nconst { fireEvent, isArray, objectEach, uniqueKey } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class to manage columns and rows in a table structure. It provides methods\n * to add, remove, and manipulate columns and rows, as well as to retrieve data\n * from specific cells.\n *\n * @class\n * @name Highcharts.DataTable\n *\n * @param {Highcharts.DataTableOptions} [options]\n * Options to initialize the new DataTable instance.\n */\nclass DataTableCore {\n    /**\n     * Constructs an instance of the DataTable class.\n     *\n     * @example\n     * const dataTable = new Highcharts.DataTableCore({\n     *   columns: {\n     *     year: [2020, 2021, 2022, 2023],\n     *     cost: [11, 13, 12, 14],\n     *     revenue: [12, 15, 14, 18]\n     *   }\n     * });\n\n     *\n     * @param {Highcharts.DataTableOptions} [options]\n     * Options to initialize the new DataTable instance.\n     */\n    constructor(options = {}) {\n        /**\n         * Whether the ID was automatic generated or given in the constructor.\n         *\n         * @name Highcharts.DataTable#autoId\n         * @type {boolean}\n         */\n        this.autoId = !options.id;\n        this.columns = {};\n        /**\n         * ID of the table for indentification purposes.\n         *\n         * @name Highcharts.DataTable#id\n         * @type {string}\n         */\n        this.id = (options.id || uniqueKey());\n        this.modified = this;\n        this.rowCount = 0;\n        this.versionTag = uniqueKey();\n        let rowCount = 0;\n        objectEach(options.columns || {}, (column, columnName) => {\n            this.columns[columnName] = column.slice();\n            rowCount = Math.max(rowCount, column.length);\n        });\n        this.applyRowCount(rowCount);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Applies a row count to the table by setting the `rowCount` property and\n     * adjusting the length of all columns.\n     *\n     * @private\n     * @param {number} rowCount The new row count.\n     */\n    applyRowCount(rowCount) {\n        this.rowCount = rowCount;\n        objectEach(this.columns, (column) => {\n            if (isArray(column)) { // Not on typed array\n                column.length = rowCount;\n            }\n        });\n    }\n    /**\n     * Fetches the given column by the canonical column name. Simplified version\n     * of the full `DataTable.getRow` method, always returning by reference.\n     *\n     * @param {string} columnName\n     * Name of the column to get.\n     *\n     * @return {Highcharts.DataTableColumn|undefined}\n     * A copy of the column, or `undefined` if not found.\n     */\n    getColumn(columnName, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        return this.columns[columnName];\n    }\n    /**\n     * Retrieves all or the given columns. Simplified version of the full\n     * `DataTable.getColumns` method, always returning by reference.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Highcharts.DataTableColumnCollection}\n     * Collection of columns. If a requested column was not found, it is\n     * `undefined`.\n     */\n    getColumns(columnNames, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        return (columnNames || Object.keys(this.columns)).reduce((columns, columnName) => {\n            columns[columnName] = this.columns[columnName];\n            return columns;\n        }, {});\n    }\n    /**\n     * Retrieves the row at a given index.\n     *\n     * @param {number} rowIndex\n     * Row index to retrieve. First row has index 0.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Record<string, number|string|undefined>|undefined}\n     * Returns the row values, or `undefined` if not found.\n     */\n    getRow(rowIndex, columnNames) {\n        return (columnNames || Object.keys(this.columns)).map((key) => this.columns[key]?.[rowIndex]);\n    }\n    /**\n     * Sets cell values for a column. Will insert a new column, if not found.\n     *\n     * @param {string} columnName\n     * Column name to set.\n     *\n     * @param {Highcharts.DataTableColumn} [column]\n     * Values to set in the column.\n     *\n     * @param {number} [rowIndex=0]\n     * Index of the first row to change. (Default: 0)\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    setColumn(columnName, column = [], rowIndex = 0, eventDetail) {\n        this.setColumns({ [columnName]: column }, rowIndex, eventDetail);\n    }\n    /**\n     * * Sets cell values for multiple columns. Will insert new columns, if not\n     * found. Simplified version of the full `DataTable.setColumns`, limited to\n     * full replacement of the columns (undefined `rowIndex`).\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. Keep undefined to reset.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    setColumns(columns, rowIndex, eventDetail) {\n        let rowCount = this.rowCount;\n        objectEach(columns, (column, columnName) => {\n            this.columns[columnName] = column.slice();\n            rowCount = column.length;\n        });\n        this.applyRowCount(rowCount);\n        if (!eventDetail?.silent) {\n            fireEvent(this, 'afterSetColumns');\n            this.versionTag = uniqueKey();\n        }\n    }\n    /**\n     * Sets cell values of a row. Will insert a new row if no index was\n     * provided, or if the index is higher than the total number of table rows.\n     * A simplified version of the full `DateTable.setRow`, limited to objects.\n     *\n     * @param {Record<string, number|string|undefined>} row\n     * Cell values to set.\n     *\n     * @param {number} [rowIndex]\n     * Index of the row to set. Leave `undefind` to add as a new row.\n     *\n     * @param {boolean} [insert]\n     * Whether to insert the row at the given index, or to overwrite the row.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #afterSetRows\n     */\n    setRow(row, rowIndex = this.rowCount, insert, eventDetail) {\n        const { columns } = this, indexRowCount = insert ? this.rowCount + 1 : rowIndex + 1;\n        objectEach(row, (cellValue, columnName) => {\n            const column = columns[columnName] ||\n                eventDetail?.addColumns !== false && new Array(indexRowCount);\n            if (column) {\n                if (insert) {\n                    column.splice(rowIndex, 0, cellValue);\n                }\n                else {\n                    column[rowIndex] = cellValue;\n                }\n                columns[columnName] = column;\n            }\n        });\n        if (indexRowCount > this.rowCount) {\n            this.applyRowCount(indexRowCount);\n        }\n        if (!eventDetail?.silent) {\n            fireEvent(this, 'afterSetRows');\n            this.versionTag = uniqueKey();\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Data_DataTableCore = (DataTableCore);\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * A column of values in a data table.\n * @typedef {Array<boolean|null|number|string|undefined>} Highcharts.DataTableColumn\n */ /**\n* A collection of data table columns defined by a object where the key is the\n* column name and the value is an array of the column values.\n* @typedef {Record<string, Highcharts.DataTableColumn>} Highcharts.DataTableColumnCollection\n*/\n/**\n * Options for the `DataTable` or `DataTableCore` classes.\n * @interface Highcharts.DataTableOptions\n */ /**\n* The column options for the data table. The columns are defined by an object\n* where the key is the column ID and the value is an array of the column\n* values.\n*\n* @name Highcharts.DataTableOptions.columns\n* @type {Highcharts.DataTableColumnCollection|undefined}\n*/ /**\n* Custom ID to identify the new DataTable instance.\n*\n* @name Highcharts.DataTableOptions.id\n* @type {string|undefined}\n*/\n(''); // Keeps doclets above in JS file\n\n;// ./code/es-modules/Extensions/MarkerClusters/MarkerClusterScatter.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2024 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n\nconst { animObject } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n\n\nconst { cluster: clusterDefaults } = MarkerClusters_MarkerClusterDefaults;\n\nconst { addEvent, defined, error, isArray: MarkerClusterScatter_isArray, isFunction, isObject, isNumber, merge, objectEach: MarkerClusterScatter_objectEach, relativeLength, syncTimeout } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Constants\n *\n * */\nconst markerClusterAlgorithms = {\n    grid: function (dataX, dataY, dataIndexes, options) {\n        const series = this, grid = {}, gridOffset = series.getGridOffset(), scaledGridSize = series.getScaledGridSize(options);\n        let x, y, gridX, gridY, key, i;\n        for (i = 0; i < dataX.length; i++) {\n            const p = valuesToPixels(series, { x: dataX[i], y: dataY[i] });\n            x = p.x - gridOffset.plotLeft;\n            y = p.y - gridOffset.plotTop;\n            gridX = Math.floor(x / scaledGridSize);\n            gridY = Math.floor(y / scaledGridSize);\n            key = gridY + ':' + gridX;\n            grid[key] ?? (grid[key] = []);\n            grid[key].push({\n                dataIndex: dataIndexes[i],\n                x: dataX[i],\n                y: dataY[i]\n            });\n        }\n        return grid;\n    },\n    kmeans: function (dataX, dataY, dataIndexes, options) {\n        const series = this, clusters = [], noise = [], group = {}, pointMaxDistance = options.processedDistance ||\n            clusterDefaults.layoutAlgorithm.distance, iterations = options.iterations, \n        // Max pixel difference beetwen new and old cluster position.\n        maxClusterShift = 1;\n        let currentIteration = 0, repeat = true, pointX = 0, pointY = 0, tempPos, pointClusterDistance = [];\n        options.processedGridSize = options.processedDistance;\n        // Use grid method to get groupedData object.\n        const groupedData = series.markerClusterAlgorithms ?\n            series.markerClusterAlgorithms.grid.call(series, dataX, dataY, dataIndexes, options) : {};\n        // Find clusters amount and its start positions\n        // based on grid grouped data.\n        for (const key in groupedData) {\n            if (groupedData[key].length > 1) {\n                tempPos = getClusterPosition(groupedData[key]);\n                clusters.push({\n                    posX: tempPos.x,\n                    posY: tempPos.y,\n                    oldX: 0,\n                    oldY: 0,\n                    startPointsLen: groupedData[key].length,\n                    points: []\n                });\n            }\n        }\n        // Start kmeans iteration process.\n        while (repeat) {\n            for (const c of clusters) {\n                c.points.length = 0;\n            }\n            noise.length = 0;\n            for (let i = 0; i < dataX.length; i++) {\n                pointX = dataX[i];\n                pointY = dataY[i];\n                pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                if (pointClusterDistance.length &&\n                    pointClusterDistance[0].distance < pointMaxDistance) {\n                    clusters[pointClusterDistance[0].clusterIndex].points.push({\n                        x: pointX,\n                        y: pointY,\n                        dataIndex: dataIndexes[i]\n                    });\n                }\n                else {\n                    noise.push({\n                        x: pointX,\n                        y: pointY,\n                        dataIndex: dataIndexes[i]\n                    });\n                }\n            }\n            // When cluster points array has only one point the\n            // point should be classified again.\n            for (let i = 0; i < clusters.length; i++) {\n                if (clusters[i].points.length === 1) {\n                    pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                    if (pointClusterDistance[1].distance < pointMaxDistance) {\n                        // Add point to the next closest cluster.\n                        clusters[pointClusterDistance[1].clusterIndex].points\n                            .push(clusters[i].points[0]);\n                        // Clear points array.\n                        clusters[pointClusterDistance[0].clusterIndex]\n                            .points.length = 0;\n                    }\n                }\n            }\n            // Compute a new clusters position and check if it\n            // is different than the old one.\n            repeat = false;\n            for (let i = 0; i < clusters.length; i++) {\n                tempPos = getClusterPosition(clusters[i].points);\n                clusters[i].oldX = clusters[i].posX;\n                clusters[i].oldY = clusters[i].posY;\n                clusters[i].posX = tempPos.x;\n                clusters[i].posY = tempPos.y;\n                // Repeat the algorithm if at least one cluster\n                // is shifted more than maxClusterShift property.\n                if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                    clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                    clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                    clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                    repeat = true;\n                }\n            }\n            // If iterations property is set repeat the algorithm\n            // specified amount of times.\n            if (iterations) {\n                repeat = currentIteration < iterations - 1;\n            }\n            currentIteration++;\n        }\n        for (let i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n            group['cluster' + i] = clusters[i].points;\n        }\n        for (let i = 0, iEnd = noise.length; i < iEnd; ++i) {\n            group['noise' + i] = [noise[i]];\n        }\n        return group;\n    },\n    optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n        const series = this, pointMaxDistance = options.processedDistance ||\n            clusterDefaults.layoutAlgorithm.gridSize, extremes = series.getRealExtremes(), clusterMarkerOptions = (series.options.cluster || {}).marker;\n        let distance, group = {}, offset, radius;\n        if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n            series.initMinX && series.initMinX > extremes.minX ||\n            series.initMaxY && series.initMaxY < extremes.maxY ||\n            series.initMinY && series.initMinY > extremes.minY)) {\n            series.initMaxX = extremes.maxX;\n            series.initMinX = extremes.minX;\n            series.initMaxY = extremes.maxY;\n            series.initMinY = extremes.minY;\n            group = series.markerClusterAlgorithms ?\n                series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n            series.baseClusters = null;\n        }\n        else {\n            series.baseClusters ?? (series.baseClusters = {\n                clusters: series.markerClusterInfo.clusters,\n                noise: series.markerClusterInfo.noise\n            });\n            for (const cluster of series.baseClusters.clusters) {\n                cluster.pointsOutside = [];\n                cluster.pointsInside = [];\n                for (const dataPoint of cluster.data) {\n                    const dataPointPx = valuesToPixels(series, dataPoint), clusterPx = valuesToPixels(series, cluster);\n                    distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                        Math.pow(dataPointPx.y - clusterPx.y, 2));\n                    if (cluster.clusterZone?.marker?.radius) {\n                        radius = cluster.clusterZone.marker.radius;\n                    }\n                    else if (clusterMarkerOptions?.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else {\n                        radius = clusterDefaults.marker.radius;\n                    }\n                    offset = pointMaxDistance - radius >= 0 ?\n                        pointMaxDistance - radius : radius;\n                    if (distance > radius + offset &&\n                        defined(cluster.pointsOutside)) {\n                        cluster.pointsOutside.push(dataPoint);\n                    }\n                    else if (defined(cluster.pointsInside)) {\n                        cluster.pointsInside.push(dataPoint);\n                    }\n                }\n                if (cluster.pointsInside.length) {\n                    group[cluster.id] = cluster.pointsInside;\n                }\n                let i = 0;\n                for (const p of cluster.pointsOutside) {\n                    group[cluster.id + '_noise' + i++] = [p];\n                }\n            }\n            for (const noise of series.baseClusters.noise) {\n                group[noise.id] = noise.data;\n            }\n        }\n        return group;\n    }\n};\n/* *\n *\n *  Variables\n *\n * */\nlet baseGeneratePoints, \n/**\n * Points that ids are included in the oldPointsStateId array are hidden\n * before animation. Other ones are destroyed.\n * @private\n */\noldPointsStateId = [], stateIdCounter = 0;\n/* *\n *\n *  Functions\n *\n * */\n/** @private */\nfunction compose(highchartsDefaultOptions, ScatterSeriesClass) {\n    const scatterProto = ScatterSeriesClass.prototype;\n    if (!scatterProto.markerClusterAlgorithms) {\n        baseGeneratePoints = scatterProto.generatePoints;\n        scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n        scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n        scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n        scatterProto.generatePoints = seriesGeneratePoints;\n        scatterProto.getClusterDistancesFromPoint =\n            seriesGetClusterDistancesFromPoint;\n        scatterProto.getClusteredData = seriesGetClusteredData;\n        scatterProto.getGridOffset = seriesGetGridOffset;\n        scatterProto.getPointsState = seriesGetPointsState;\n        scatterProto.getRealExtremes = seriesGetRealExtremes;\n        scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n        scatterProto.hideClusteredData = seriesHideClusteredData;\n        scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n        scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n        // Destroy grouped data on series destroy.\n        addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n        if (highchartsDefaultOptions.plotOptions) {\n            highchartsDefaultOptions.plotOptions.series = merge(highchartsDefaultOptions.plotOptions.series, MarkerClusters_MarkerClusterDefaults);\n        }\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction destroyOldPoints(oldState) {\n    for (const key of Object.keys(oldState)) {\n        oldState[key].point?.destroy?.();\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInElement(elem, opacity, animation) {\n    elem.attr({ opacity }).animate({ opacity: 1 }, animation);\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n    // Fade in new point.\n    fadeInStatePoint(newPointObj, opacity, animation, true, true);\n    // Destroy old animated points.\n    for (const p of oldPoints) {\n        p.point?.destroy?.();\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n    if (stateObj.point) {\n        if (fadeinGraphic && stateObj.point.graphic) {\n            stateObj.point.graphic.show();\n            fadeInElement(stateObj.point.graphic, opacity, animation);\n        }\n        if (fadeinDataLabel && stateObj.point.dataLabel) {\n            stateObj.point.dataLabel.show();\n            fadeInElement(stateObj.point.dataLabel, opacity, animation);\n        }\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction getClusterPosition(points) {\n    const pointsLen = points.length;\n    let sumX = 0, sumY = 0;\n    for (let i = 0; i < pointsLen; i++) {\n        sumX += points[i].x;\n        sumY += points[i].y;\n    }\n    return {\n        x: sumX / pointsLen,\n        y: sumY / pointsLen\n    };\n}\n/**\n * Util function.Prepare array with sorted data objects to be compared in\n * getPointsState method.\n * @private\n */\nfunction getDataState(clusteredData, stateDataLen) {\n    const state = [];\n    state.length = stateDataLen;\n    clusteredData.clusters.forEach(function (cluster) {\n        cluster.data.forEach(function (elem) {\n            state[elem.dataIndex] = elem;\n        });\n    });\n    clusteredData.noise.forEach(function (noise) {\n        state[noise.data[0].dataIndex] = noise.data[0];\n    });\n    return state;\n}\n/**\n * Util function. Generate unique stateId for a state element.\n * @private\n */\nfunction getStateId() {\n    return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n}\n/**\n * Util function.\n * @private\n */\nfunction hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n    if (stateObj.point) {\n        if (hideGraphic && stateObj.point.graphic) {\n            stateObj.point.graphic.hide();\n        }\n        if (hideDataLabel && stateObj.point.dataLabel) {\n            stateObj.point.dataLabel.hide();\n        }\n    }\n}\n/** @private */\nfunction onPointDrillToCluster(event) {\n    const point = event.point || event.target;\n    point.firePointEvent('drillToCluster', event, function (e) {\n        const point = e.point || e.target, series = point.series, { xAxis, yAxis, chart } = series, { inverted, mapView, pointer } = chart, drillToCluster = series.options.cluster?.drillToCluster;\n        if (drillToCluster && point.clusteredData) {\n            const sortedDataX = point.clusteredData\n                .map((data) => data.x)\n                .sort((a, b) => a - b), sortedDataY = point.clusteredData\n                .map((data) => data.y)\n                .sort((a, b) => a - b), minX = sortedDataX[0], maxX = sortedDataX[sortedDataX.length - 1], minY = sortedDataY[0], maxY = sortedDataY[sortedDataY.length - 1], offsetX = Math.abs((maxX - minX) * 0.1), offsetY = Math.abs((maxY - minY) * 0.1), x1 = Math.min(minX, maxX) - offsetX, x2 = Math.max(minX, maxX) + offsetX, y1 = Math.min(minY, maxY) - offsetY, y2 = Math.max(minY, maxY) + offsetY;\n            if (mapView) {\n                mapView.fitToBounds({ x1, x2, y1, y2 });\n            }\n            else if (xAxis && yAxis) {\n                let x1Px = xAxis.toPixels(x1), x2Px = xAxis.toPixels(x2), y1Px = yAxis.toPixels(y1), y2Px = yAxis.toPixels(y2);\n                if (inverted) {\n                    [x1Px, x2Px, y1Px, y2Px] = [y1Px, y2Px, x1Px, x2Px];\n                }\n                if (x1Px > x2Px) {\n                    [x1Px, x2Px] = [x2Px, x1Px];\n                }\n                if (y1Px > y2Px) {\n                    [y1Px, y2Px] = [y2Px, y1Px];\n                }\n                if (pointer) {\n                    pointer.zoomX = true;\n                    pointer.zoomY = true;\n                }\n                chart.transform({\n                    from: {\n                        x: x1Px,\n                        y: y1Px,\n                        width: x2Px - x1Px,\n                        height: y2Px - y1Px\n                    }\n                });\n            }\n        }\n    });\n}\n/**\n * Util function.\n * @private\n */\nfunction pixelsToValues(series, pos) {\n    const { chart, xAxis, yAxis } = series;\n    if (chart.mapView) {\n        return chart.mapView.pixelsToProjectedUnits(pos);\n    }\n    return {\n        x: xAxis ? xAxis.toValue(pos.x) : 0,\n        y: yAxis ? yAxis.toValue(pos.y) : 0\n    };\n}\n/** @private */\nfunction seriesAnimateClusterPoint(clusterObj) {\n    const series = this, chart = series.chart, mapView = chart.mapView, animation = animObject(series.options.cluster?.animation), animDuration = animation.duration || 500, pointsState = series.markerClusterInfo?.pointsState, newState = pointsState?.newState, oldState = pointsState?.oldState, oldPoints = [];\n    let parentId, oldPointObj, newPointObj, newPointBBox, offset = 0, newX = 0, newY = 0, isOldPointGrahic = false, isCbHandled = false;\n    if (oldState && newState) {\n        newPointObj = newState[clusterObj.stateId];\n        const newPos = valuesToPixels(series, newPointObj);\n        newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n        newY = newPos.y - (mapView ? 0 : chart.plotTop);\n        // Point has one ancestor.\n        if (newPointObj.parentsId.length === 1) {\n            parentId = newState?.[clusterObj.stateId].parentsId[0];\n            oldPointObj = oldState[parentId];\n            // If old and new positions are the same do not animate.\n            if (newPointObj.point?.graphic &&\n                oldPointObj.point?.plotX &&\n                oldPointObj.point.plotY &&\n                (oldPointObj.point.plotX !== newPointObj.point.plotX ||\n                    oldPointObj.point.plotY !== newPointObj.point.plotY)) {\n                newPointBBox = newPointObj.point.graphic.getBBox();\n                // Marker image does not have the offset (#14342).\n                offset = newPointObj.point.graphic?.isImg ?\n                    0 : newPointBBox.width / 2;\n                newPointObj.point.graphic.attr({\n                    x: oldPointObj.point.plotX - offset,\n                    y: oldPointObj.point.plotY - offset\n                });\n                newPointObj.point.graphic.animate({\n                    x: newX - (newPointObj.point.graphic.radius || 0),\n                    y: newY - (newPointObj.point.graphic.radius || 0)\n                }, animation, function () {\n                    isCbHandled = true;\n                    // Destroy old point.\n                    oldPointObj.point?.destroy?.();\n                });\n                // Data label animation.\n                if (newPointObj.point.dataLabel?.alignAttr &&\n                    oldPointObj.point.dataLabel?.alignAttr) {\n                    newPointObj.point.dataLabel.attr({\n                        x: oldPointObj.point.dataLabel.alignAttr.x,\n                        y: oldPointObj.point.dataLabel.alignAttr.y\n                    });\n                    newPointObj.point.dataLabel.animate({\n                        x: newPointObj.point.dataLabel.alignAttr.x,\n                        y: newPointObj.point.dataLabel.alignAttr.y\n                    }, animation);\n                }\n            }\n        }\n        else if (newPointObj.parentsId.length === 0) {\n            // Point has no ancestors - new point.\n            // Hide new point.\n            hideStatePoint(newPointObj, true, true);\n            syncTimeout(function () {\n                // Fade in new point.\n                fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n            }, animDuration / 2);\n        }\n        else {\n            // Point has many ancestors.\n            // Hide new point before animation.\n            hideStatePoint(newPointObj, true, true);\n            newPointObj.parentsId.forEach(function (elem) {\n                if (oldState?.[elem]) {\n                    oldPointObj = oldState[elem];\n                    oldPoints.push(oldPointObj);\n                    if (oldPointObj.point?.graphic) {\n                        isOldPointGrahic = true;\n                        oldPointObj.point.graphic.show();\n                        oldPointObj.point.graphic.animate({\n                            x: newX - (oldPointObj.point.graphic.radius || 0),\n                            y: newY - (oldPointObj.point.graphic.radius || 0),\n                            opacity: 0.4\n                        }, animation, function () {\n                            isCbHandled = true;\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                        });\n                        if (oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.y !== -9999 &&\n                            newPointObj.point?.dataLabel?.alignAttr) {\n                            oldPointObj.point.dataLabel.show();\n                            oldPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y,\n                                opacity: 0.4\n                            }, animation);\n                        }\n                    }\n                }\n            });\n            // Make sure point is faded in.\n            syncTimeout(function () {\n                if (!isCbHandled) {\n                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                }\n            }, animDuration);\n            if (!isOldPointGrahic) {\n                syncTimeout(function () {\n                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                }, animDuration / 2);\n            }\n        }\n    }\n}\n/**\n * Destroy clustered data points.\n * @private\n */\nfunction seriesDestroyClusteredData() {\n    // Clear previous groups.\n    this.markerClusterSeriesData?.forEach((point) => {\n        point?.destroy?.();\n    });\n    this.markerClusterSeriesData = null;\n}\n/**\n * Override the generatePoints method by adding a reference to grouped data.\n * @private\n */\nfunction seriesGeneratePoints() {\n    const series = this, { chart } = series, mapView = chart.mapView, xData = series.getColumn('x'), yData = series.getColumn('y'), clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n    let oldPointsState, oldDataLen, oldMarkerClusterInfo, kmeansThreshold, cropDataOffsetX, cropDataOffsetY, seriesMinX, seriesMaxX, seriesMinY, seriesMaxY, type, algorithm, clusteredData, groupedData, layoutAlgOptions, point;\n    // For map point series, we need to resolve lon, lat and geometry options\n    // and project them on the plane in order to get x and y. In the regular\n    // series flow, this is not done until the `translate` method because the\n    // resulting [x, y] position depends on inset positions in the MapView.\n    if (mapView && series.is('mappoint') && xData && yData) {\n        series.options.data?.forEach((p, i) => {\n            const xy = series.projectPoint(p);\n            if (xy) {\n                xData[i] = xy.x;\n                yData[i] = xy.y;\n            }\n        });\n    }\n    if (clusterOptions?.enabled &&\n        xData?.length &&\n        yData?.length &&\n        !chart.polar) {\n        type = clusterOptions.layoutAlgorithm.type;\n        layoutAlgOptions = clusterOptions.layoutAlgorithm;\n        // Get processed algorithm properties.\n        layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n            clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n        layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n            clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n        kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n            clusterDefaults.layoutAlgorithm.kmeansThreshold;\n        // Offset to prevent cluster size changes.\n        const halfGrid = layoutAlgOptions.processedGridSize / 2, p1 = pixelsToValues(series, { x: 0, y: 0 }), p2 = pixelsToValues(series, { x: halfGrid, y: halfGrid });\n        cropDataOffsetX = Math.abs(p1.x - p2.x);\n        cropDataOffsetY = Math.abs(p1.y - p2.y);\n        // Get only visible data.\n        for (let i = 0; i < xData.length; i++) {\n            if (!series.dataMaxX) {\n                if (!defined(seriesMaxX) ||\n                    !defined(seriesMinX) ||\n                    !defined(seriesMaxY) ||\n                    !defined(seriesMinY)) {\n                    seriesMaxX = seriesMinX = xData[i];\n                    seriesMaxY = seriesMinY = yData[i];\n                }\n                else if (isNumber(yData[i]) &&\n                    isNumber(seriesMaxY) &&\n                    isNumber(seriesMinY)) {\n                    seriesMaxX = Math.max(xData[i], seriesMaxX);\n                    seriesMinX = Math.min(xData[i], seriesMinX);\n                    seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                    seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                }\n            }\n            // Crop data to visible ones with appropriate offset to prevent\n            // cluster size changes on the edge of the plot area.\n            if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                (yData[i] || realExtremes.minY) >=\n                    (realExtremes.minY - cropDataOffsetY) &&\n                (yData[i] || realExtremes.maxY) <=\n                    (realExtremes.maxY + cropDataOffsetY)) {\n                visibleXData.push(xData[i]);\n                visibleYData.push(yData[i]);\n                visibleDataIndexes.push(i);\n            }\n        }\n        // Save data max values.\n        if (defined(seriesMaxX) && defined(seriesMinX) &&\n            isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n            series.dataMaxX = seriesMaxX;\n            series.dataMinX = seriesMinX;\n            series.dataMaxY = seriesMaxY;\n            series.dataMinY = seriesMinY;\n        }\n        if (isFunction(type)) {\n            algorithm = type;\n        }\n        else if (series.markerClusterAlgorithms) {\n            if (type && series.markerClusterAlgorithms[type]) {\n                algorithm = series.markerClusterAlgorithms[type];\n            }\n            else {\n                algorithm = visibleXData.length < kmeansThreshold ?\n                    series.markerClusterAlgorithms.kmeans :\n                    series.markerClusterAlgorithms.grid;\n            }\n        }\n        else {\n            algorithm = () => false;\n        }\n        groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n        clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n        // When animation is enabled get old points state.\n        if (clusterOptions.animation &&\n            series.markerClusterInfo?.pointsState?.oldState) {\n            // Destroy old points.\n            destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n            oldPointsState = series.markerClusterInfo.pointsState.newState;\n        }\n        else {\n            oldPointsState = {};\n        }\n        // Save points old state info.\n        oldDataLen = xData.length;\n        oldMarkerClusterInfo = series.markerClusterInfo;\n        if (clusteredData) {\n            series.dataTable.modified = new Data_DataTableCore({\n                columns: {\n                    x: clusteredData.groupedXData,\n                    y: clusteredData.groupedYData\n                }\n            });\n            series.hasGroupedData = true;\n            series.markerClusterInfo = clusteredData;\n            series.groupMap = clusteredData.groupMap;\n        }\n        baseGeneratePoints.apply(this);\n        if (clusteredData && series.markerClusterInfo) {\n            // Mark cluster points. Safe point reference in the cluster object.\n            series.markerClusterInfo.clusters?.forEach((cluster) => {\n                point = series.points[cluster.index];\n                point.isCluster = true;\n                point.clusteredData = cluster.data;\n                point.clusterPointsAmount = cluster.data.length;\n                cluster.point = point;\n                // Add zoom to cluster range.\n                addEvent(point, 'click', onPointDrillToCluster);\n            });\n            // Safe point reference in the noise object.\n            series.markerClusterInfo.noise?.forEach((noise) => {\n                noise.point = series.points[noise.index];\n            });\n            // When animation is enabled save points state.\n            if (clusterOptions.animation &&\n                series.markerClusterInfo) {\n                series.markerClusterInfo.pointsState = {\n                    oldState: oldPointsState,\n                    newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                };\n            }\n            // Record grouped data in order to let it be destroyed the next time\n            // processData runs.\n            if (!clusterOptions.animation) {\n                this.destroyClusteredData();\n            }\n            else {\n                this.hideClusteredData();\n            }\n            this.markerClusterSeriesData =\n                this.hasGroupedData ? this.points : null;\n        }\n    }\n    else {\n        baseGeneratePoints.apply(this);\n    }\n}\n/** @private */\nfunction seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n    const pointClusterDistance = [];\n    for (let clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n        const p1 = valuesToPixels(this, { x: pointX, y: pointY }), p2 = valuesToPixels(this, {\n            x: clusters[clusterIndex].posX,\n            y: clusters[clusterIndex].posY\n        }), distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n            Math.pow(p1.y - p2.y, 2));\n        pointClusterDistance.push({ clusterIndex, distance });\n    }\n    return pointClusterDistance.sort((a, b) => a.distance - b.distance);\n}\n/** @private */\nfunction seriesGetClusteredData(groupedData, options) {\n    const series = this, data = series.options.data, groupedXData = [], groupedYData = [], clusters = [], // Container for clusters.\n    noise = [], // Container for points not belonging to any cluster.\n    groupMap = [], \n    // Prevent minimumClusterSize lower than 2.\n    minimumClusterSize = Math.max(2, options.minimumClusterSize || 2);\n    let index = 0, stateId, point, points, pointUserOptions, pointsLen, marker, clusterPos, pointOptions, clusterTempPos, zoneOptions, clusterZone, clusterZoneClassName;\n    // Check if groupedData is valid when user uses a custom algorithm.\n    if (isFunction(options.layoutAlgorithm.type) &&\n        !series.isValidGroupedDataObject(groupedData)) {\n        error('Highcharts marker-clusters module: ' +\n            'The custom algorithm result is not valid!', false, series.chart);\n        return false;\n    }\n    for (const k in groupedData) {\n        if (groupedData[k].length >= minimumClusterSize) {\n            points = groupedData[k];\n            stateId = getStateId();\n            pointsLen = points.length;\n            // Get zone options for cluster.\n            if (options.zones) {\n                for (let i = 0; i < options.zones.length; i++) {\n                    if (pointsLen >= options.zones[i].from &&\n                        pointsLen <= options.zones[i].to) {\n                        clusterZone = options.zones[i];\n                        clusterZone.zoneIndex = i;\n                        zoneOptions = options.zones[i].marker;\n                        clusterZoneClassName = options.zones[i].className;\n                    }\n                }\n            }\n            clusterTempPos = getClusterPosition(points);\n            if (options.layoutAlgorithm.type === 'grid' &&\n                !options.allowOverlap) {\n                marker = series.options.marker || {};\n                clusterPos = series.preventClusterCollisions({\n                    x: clusterTempPos.x,\n                    y: clusterTempPos.y,\n                    key: k,\n                    groupedData: groupedData,\n                    gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                    defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                    clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                        zoneOptions.radius :\n                        (options.marker || {}).radius ||\n                            clusterDefaults.marker.radius\n                });\n            }\n            else {\n                clusterPos = {\n                    x: clusterTempPos.x,\n                    y: clusterTempPos.y\n                };\n            }\n            for (let i = 0; i < pointsLen; i++) {\n                points[i].parentStateId = stateId;\n            }\n            clusters.push({\n                x: clusterPos.x,\n                y: clusterPos.y,\n                id: k,\n                stateId,\n                index,\n                data: points,\n                clusterZone,\n                clusterZoneClassName\n            });\n            groupedXData.push(clusterPos.x);\n            groupedYData.push(clusterPos.y);\n            groupMap.push({\n                options: {\n                    formatPrefix: 'cluster',\n                    dataLabels: options.dataLabels,\n                    marker: merge(options.marker, {\n                        states: options.states\n                    }, zoneOptions || {})\n                }\n            });\n            // Save cluster data points options.\n            if (data?.length) {\n                for (let i = 0; i < pointsLen; i++) {\n                    if (isObject(data[points[i].dataIndex])) {\n                        points[i].options = data[points[i].dataIndex];\n                    }\n                }\n            }\n            index++;\n            zoneOptions = null;\n        }\n        else {\n            for (let i = 0; i < groupedData[k].length; i++) {\n                // Points not belonging to any cluster.\n                point = groupedData[k][i];\n                stateId = getStateId();\n                pointOptions = null;\n                pointUserOptions = data?.[point.dataIndex];\n                groupedXData.push(point.x);\n                groupedYData.push(point.y);\n                point.parentStateId = stateId;\n                noise.push({\n                    x: point.x,\n                    y: point.y,\n                    id: k,\n                    stateId,\n                    index,\n                    data: groupedData[k]\n                });\n                if (pointUserOptions &&\n                    typeof pointUserOptions === 'object' &&\n                    !MarkerClusterScatter_isArray(pointUserOptions)) {\n                    pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                }\n                else {\n                    pointOptions = {\n                        userOptions: pointUserOptions,\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n                groupMap.push({ options: pointOptions });\n                index++;\n            }\n        }\n    }\n    return {\n        clusters,\n        noise,\n        groupedXData,\n        groupedYData,\n        groupMap\n    };\n}\n/** @private */\nfunction seriesGetGridOffset() {\n    const series = this, { chart, xAxis, yAxis } = series;\n    let plotLeft = 0, plotTop = 0;\n    if (xAxis && series.dataMinX && series.dataMaxX) {\n        plotLeft = xAxis.reversed ?\n            xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n    }\n    else {\n        plotLeft = chart.plotLeft;\n    }\n    if (yAxis && series.dataMinY && series.dataMaxY) {\n        plotTop = yAxis.reversed ?\n            yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n    }\n    else {\n        plotTop = chart.plotTop;\n    }\n    return { plotLeft, plotTop };\n}\n/**\n * Point state used when animation is enabled to compare and bind old points\n * with new ones.\n * @private\n */\nfunction seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n    const oldDataStateArr = oldMarkerClusterInfo ?\n        getDataState(oldMarkerClusterInfo, dataLength) : [], newDataStateArr = getDataState(clusteredData, dataLength), state = {};\n    // Clear global array before populate with new ids.\n    oldPointsStateId = [];\n    // Build points state structure.\n    clusteredData.clusters.forEach((cluster) => {\n        state[cluster.stateId] = {\n            x: cluster.x,\n            y: cluster.y,\n            id: cluster.stateId,\n            point: cluster.point,\n            parentsId: []\n        };\n    });\n    clusteredData.noise.forEach((noise) => {\n        state[noise.stateId] = {\n            x: noise.x,\n            y: noise.y,\n            id: noise.stateId,\n            point: noise.point,\n            parentsId: []\n        };\n    });\n    let newState, oldState;\n    // Bind new and old state.\n    for (let i = 0; i < newDataStateArr.length; i++) {\n        newState = newDataStateArr[i];\n        oldState = oldDataStateArr[i];\n        if (newState?.parentStateId &&\n            oldState?.parentStateId &&\n            state[newState.parentStateId]?.parentsId.indexOf(oldState.parentStateId) === -1) {\n            state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n            if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                oldPointsStateId.push(oldState.parentStateId);\n            }\n        }\n    }\n    return state;\n}\n/** @private */\nfunction seriesGetRealExtremes() {\n    const chart = this.chart, x = chart.mapView ? 0 : chart.plotLeft, y = chart.mapView ? 0 : chart.plotTop, p1 = pixelsToValues(this, {\n        x,\n        y\n    }), p2 = pixelsToValues(this, {\n        x: x + chart.plotWidth,\n        y: x + chart.plotHeight\n    }), realMinX = p1.x, realMaxX = p2.x, realMinY = p1.y, realMaxY = p2.y;\n    return {\n        minX: Math.min(realMinX, realMaxX),\n        maxX: Math.max(realMinX, realMaxX),\n        minY: Math.min(realMinY, realMaxY),\n        maxY: Math.max(realMinY, realMaxY)\n    };\n}\n/** @private */\nfunction seriesGetScaledGridSize(options) {\n    const series = this, xAxis = series.xAxis, mapView = series.chart.mapView, processedGridSize = options.processedGridSize ||\n        clusterDefaults.layoutAlgorithm.gridSize;\n    let search = true, k = 1, divider = 1;\n    if (!series.gridValueSize) {\n        if (mapView) {\n            series.gridValueSize = processedGridSize / mapView.getScale();\n        }\n        else {\n            series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n        }\n    }\n    const gridSize = mapView ?\n        series.gridValueSize * mapView.getScale() :\n        xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n    const scale = +(processedGridSize / gridSize).toFixed(14);\n    // Find the level and its divider.\n    while (search && scale !== 1) {\n        const level = Math.pow(2, k);\n        if (scale > 0.75 && scale < 1.25) {\n            search = false;\n        }\n        else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n            search = false;\n            divider = level;\n        }\n        else if (scale <= level && scale > level / 2) {\n            search = false;\n            divider = 1 / level;\n        }\n        k++;\n    }\n    return (processedGridSize / divider) / scale;\n}\n/**\n * Hide clustered data points.\n * @private\n */\nfunction seriesHideClusteredData() {\n    const clusteredSeriesData = this.markerClusterSeriesData, oldState = this.markerClusterInfo?.pointsState?.oldState, oldPointsId = oldPointsStateId.map((elem) => oldState?.[elem].point?.id || '');\n    clusteredSeriesData?.forEach((point) => {\n        // If an old point is used in animation hide it, otherwise destroy.\n        if (point &&\n            oldPointsId.indexOf(point.id) !== -1) {\n            if (point.graphic) {\n                point.graphic.hide();\n            }\n            if (point.dataLabel) {\n                point.dataLabel.hide();\n            }\n        }\n        else {\n            point?.destroy?.();\n        }\n    });\n}\n/**\n * Check if user algorithm result is valid groupedDataObject.\n * @private\n */\nfunction seriesIsValidGroupedDataObject(groupedData) {\n    let result = false;\n    if (!isObject(groupedData)) {\n        return false;\n    }\n    MarkerClusterScatter_objectEach(groupedData, (elem) => {\n        result = true;\n        if (!MarkerClusterScatter_isArray(elem) || !elem.length) {\n            result = false;\n            return;\n        }\n        for (let i = 0; i < elem.length; i++) {\n            if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                result = false;\n                return;\n            }\n        }\n    });\n    return result;\n}\n/** @private */\nfunction seriesPreventClusterCollisions(props) {\n    const series = this, [gridY, gridX] = props.key.split(':').map(parseFloat), gridSize = props.gridSize, groupedData = props.groupedData, defaultRadius = props.defaultRadius, clusterRadius = props.clusterRadius, gridXPx = gridX * gridSize, gridYPx = gridY * gridSize, propsPx = valuesToPixels(series, props), gridsToCheckCollision = [], clusterMarkerOptions = series.options.cluster?.marker, zoneOptions = series.options.cluster?.zones, gridOffset = series.getGridOffset();\n    let xPixel = propsPx.x, yPixel = propsPx.y, pointsLen = 0, radius = 0, nextXPixel, nextYPixel, signX, signY, cornerGridX, cornerGridY, j, itemX, itemY, nextClusterPos, maxDist, keys;\n    // Distance to the grid start.\n    xPixel -= gridOffset.plotLeft;\n    yPixel -= gridOffset.plotTop;\n    for (let i = 1; i < 5; i++) {\n        signX = i % 2 ? -1 : 1;\n        signY = i < 3 ? -1 : 1;\n        cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n        cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n        keys = [\n            cornerGridY + ':' + cornerGridX,\n            cornerGridY + ':' + gridX,\n            gridY + ':' + cornerGridX\n        ];\n        for (j = 0; j < keys.length; j++) {\n            if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                keys[j] !== props.key) {\n                gridsToCheckCollision.push(keys[j]);\n            }\n        }\n    }\n    for (const item of gridsToCheckCollision) {\n        if (groupedData[item]) {\n            // Cluster or noise position is already computed.\n            if (!groupedData[item].posX) {\n                nextClusterPos = getClusterPosition(groupedData[item]);\n                groupedData[item].posX = nextClusterPos.x;\n                groupedData[item].posY = nextClusterPos.y;\n            }\n            const pos = valuesToPixels(series, {\n                x: groupedData[item].posX || 0,\n                y: groupedData[item].posY || 0\n            });\n            nextXPixel = pos.x - gridOffset.plotLeft;\n            nextYPixel = pos.y - gridOffset.plotTop;\n            [itemY, itemX] = item.split(':').map(parseFloat);\n            if (zoneOptions) {\n                pointsLen = groupedData[item].length;\n                for (let i = 0; i < zoneOptions.length; i++) {\n                    if (pointsLen >= zoneOptions[i].from &&\n                        pointsLen <= zoneOptions[i].to) {\n                        if (defined(zoneOptions[i].marker?.radius)) {\n                            radius = zoneOptions[i].marker.radius || 0;\n                        }\n                        else if (clusterMarkerOptions?.radius) {\n                            radius = clusterMarkerOptions.radius;\n                        }\n                        else {\n                            radius = clusterDefaults.marker.radius;\n                        }\n                    }\n                }\n            }\n            if (groupedData[item].length > 1 &&\n                radius === 0 &&\n                clusterMarkerOptions?.radius) {\n                radius = clusterMarkerOptions.radius;\n            }\n            else if (groupedData[item].length === 1) {\n                radius = defaultRadius;\n            }\n            maxDist = clusterRadius + radius;\n            radius = 0;\n            if (itemX !== gridX &&\n                Math.abs(xPixel - nextXPixel) < maxDist) {\n                xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                    gridXPx + gridSize - clusterRadius;\n            }\n            if (itemY !== gridY &&\n                Math.abs(yPixel - nextYPixel) < maxDist) {\n                yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                    gridYPx + gridSize - clusterRadius;\n            }\n        }\n    }\n    const pos = pixelsToValues(series, {\n        x: xPixel + gridOffset.plotLeft,\n        y: yPixel + gridOffset.plotTop\n    });\n    groupedData[props.key].posX = pos.x;\n    groupedData[props.key].posY = pos.y;\n    return pos;\n}\n/**\n * Util function.\n * @private\n */\nfunction valuesToPixels(series, pos) {\n    const { chart, xAxis, yAxis } = series;\n    if (chart.mapView) {\n        return chart.mapView.projectedUnitsToPixels(pos);\n    }\n    return {\n        x: xAxis ? xAxis.toPixels(pos.x) : 0,\n        y: yAxis ? yAxis.toPixels(pos.y) : 0\n    };\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MarkerClusterScatter = {\n    compose\n};\n/* harmony default export */ const MarkerClusters_MarkerClusterScatter = (MarkerClusterScatter);\n\n;// ./code/es-modules/Extensions/MarkerClusters/MarkerClusters.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2024 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n\nconst { animObject: MarkerClusters_animObject } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n\nconst { defaultOptions } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n\nconst { composed } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n\n\n\nconst { addEvent: MarkerClusters_addEvent, defined: MarkerClusters_defined, error: MarkerClusters_error, isFunction: MarkerClusters_isFunction, merge: MarkerClusters_merge, pushUnique, syncTimeout: MarkerClusters_syncTimeout } = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\n/* *\n *\n *  Constants\n *\n * */\n(defaultOptions.plotOptions || {}).series = MarkerClusters_merge((defaultOptions.plotOptions || {}).series, MarkerClusters_MarkerClusterDefaults);\n/* *\n *\n *  Functions\n *\n * */\n/** @private */\nfunction MarkerClusters_compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n    if (pushUnique(composed, 'MarkerClusters')) {\n        const PointClass = SeriesClass.prototype.pointClass, { scatter: ScatterSeries } = SeriesClass.types;\n        MarkerClusters_addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n        MarkerClusters_addEvent(ChartClass, 'render', onChartRender);\n        MarkerClusters_addEvent(PointClass, 'drillToCluster', MarkerClusters_onPointDrillToCluster);\n        MarkerClusters_addEvent(PointClass, 'update', onPointUpdate);\n        MarkerClusters_addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n        if (ScatterSeries) {\n            MarkerClusters_MarkerClusterScatter\n                .compose(highchartsDefaultOptions, ScatterSeries);\n        }\n    }\n}\n/**\n * Destroy the old tooltip after zoom.\n * @private\n */\nfunction onAxisSetExtremes() {\n    const chart = this.chart;\n    let animationDuration = 0;\n    for (const series of chart.series) {\n        if (series.markerClusterInfo) {\n            animationDuration = (MarkerClusters_animObject((series.options.cluster || {}).animation).duration ||\n                0);\n        }\n    }\n    MarkerClusters_syncTimeout(() => {\n        if (chart.tooltip) {\n            chart.tooltip.destroy();\n        }\n    }, animationDuration);\n}\n/**\n * Handle animation.\n * @private\n */\nfunction onChartRender() {\n    const chart = this;\n    for (const series of (chart.series || [])) {\n        if (series.markerClusterInfo) {\n            const options = series.options.cluster, pointsState = (series.markerClusterInfo || {}).pointsState, oldState = (pointsState || {}).oldState;\n            if ((options || {}).animation &&\n                series.markerClusterInfo &&\n                (series.chart.pointer?.pinchDown || []).length === 0 &&\n                ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                oldState &&\n                Object.keys(oldState).length) {\n                for (const cluster of series.markerClusterInfo.clusters) {\n                    series.animateClusterPoint(cluster);\n                }\n                for (const noise of series.markerClusterInfo.noise) {\n                    series.animateClusterPoint(noise);\n                }\n            }\n        }\n    }\n}\n/** @private */\nfunction MarkerClusters_onPointDrillToCluster(event) {\n    const point = event.point || event.target, series = point.series, clusterOptions = series.options.cluster, onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n    if (MarkerClusters_isFunction(onDrillToCluster)) {\n        onDrillToCluster.call(this, event);\n    }\n}\n/**\n * Override point prototype to throw a warning when trying to update\n * clustered point.\n * @private\n */\nfunction onPointUpdate() {\n    const point = this;\n    if (point.dataGroup) {\n        MarkerClusters_error('Highcharts marker-clusters module: ' +\n            'Running `Point.update` when point belongs to clustered series' +\n            ' is not supported.', false, point.series.chart);\n        return false;\n    }\n}\n/**\n * Add classes, change mouse cursor.\n * @private\n */\nfunction onSeriesAfterRender() {\n    const series = this, clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n    if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n        for (const cluster of series.markerClusterInfo.clusters) {\n            if (cluster.point && cluster.point.graphic) {\n                cluster.point.graphic.addClass('highcharts-cluster-point');\n                // Change cursor to pointer when drillToCluster is enabled.\n                if (clusterZoomEnabled && cluster.point) {\n                    cluster.point.graphic.css({\n                        cursor: 'pointer'\n                    });\n                    if (cluster.point.dataLabel) {\n                        cluster.point.dataLabel.css({\n                            cursor: 'pointer'\n                        });\n                    }\n                }\n                if (MarkerClusters_defined(cluster.clusterZone)) {\n                    cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                        'highcharts-cluster-zone-' +\n                            cluster.clusterZone.zoneIndex);\n                }\n            }\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MarkerClusters = {\n    compose: MarkerClusters_compose\n};\n/* harmony default export */ const MarkerClusters_MarkerClusters = (MarkerClusters);\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Function callback when a cluster is clicked.\n *\n * @callback Highcharts.MarkerClusterDrillCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point where the event occurred.\n *\n * @param {Highcharts.PointClickEventObject} event\n *        Event arguments.\n */\n''; // Keeps doclets above in JS file\n\n;// ./code/es-modules/Extensions/MarkerClusters/MarkerClusterSymbols.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2024 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n/* *\n *\n *  Variables\n *\n * */\nlet symbols;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Cluster symbol.\n * @private\n */\nfunction MarkerClusterSymbols_cluster(x, y, width, height) {\n    const w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n        start: Math.PI * 0.5,\n        end: Math.PI * 2.5,\n        open: false\n    }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n        start: Math.PI * 0.5,\n        end: Math.PI * 2.5,\n        innerR: w - outerWidth * 2,\n        open: false\n    }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n        start: Math.PI * 0.5,\n        end: Math.PI * 2.5,\n        innerR: w,\n        open: false\n    });\n    return outer2.concat(outer1, inner);\n}\n/**\n * @private\n */\nfunction MarkerClusterSymbols_compose(SVGRendererClass) {\n    symbols = SVGRendererClass.prototype.symbols;\n    symbols.cluster = MarkerClusterSymbols_cluster;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MarkerClusterSymbols = {\n    compose: MarkerClusterSymbols_compose\n};\n/* harmony default export */ const MarkerClusters_MarkerClusterSymbols = (MarkerClusterSymbols);\n\n;// ./code/es-modules/masters/modules/marker-clusters.src.js\n\n\n\n\n\nconst G = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\nMarkerClusters_MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\nMarkerClusters_MarkerClusterSymbols.compose(G.SVGRenderer);\n/* harmony default export */ const marker_clusters_src = ((highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()));\n\n__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":["root","factory","exports","module","define","amd","amd1","window","__WEBPACK_EXTERNAL_MODULE__944__","symbols","__webpack_modules__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__","marker_clusters_src","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default","MarkerClusters_MarkerClusterDefaults","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","fireEvent","isArray","objectEach","uniqueKey","Data_DataTableCore","constructor","options","autoId","id","columns","modified","rowCount","versionTag","column","columnName","slice","Math","max","length","applyRowCount","getColumn","asReference","getColumns","columnNames","keys","reduce","getRow","rowIndex","map","setColumn","eventDetail","setColumns","silent","setRow","row","insert","indexRowCount","cellValue","addColumns","Array","splice","animObject","clusterDefaults","addEvent","defined","error","MarkerClusterScatter_isArray","isFunction","isObject","isNumber","merge","MarkerClusterScatter_objectEach","relativeLength","syncTimeout","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","x","y","gridX","i","gridOffset","series","getGridOffset","scaledGridSize","getScaledGridSize","p","valuesToPixels","plotLeft","plotTop","floor","gridY","push","dataIndex","kmeans","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","tempPos","pointClusterDistance","processedGridSize","groupedData","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","extremes","getRealExtremes","clusterMarkerOptions","offset","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","dataPoint","pointsOutside","pointsInside","data","dataPointPx","clusterPx","sqrt","pow","clusterZone","baseGeneratePoints","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","inverted","mapView","pointer","sortedDataX","sort","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","y1","y2","fitToBounds","x1Px","toPixels","x2Px","y1Px","y2Px","zoomX","zoomY","transform","from","width","height","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","animDuration","pointsState","newState","oldState","oldPointObj","newPointBBox","newX","newY","isOldPointGrahic","isCbHandled","newPos","stateId","parentsId","plotX","plotY","getBBox","isImg","alignAttr","seriesDestroyClusteredData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","layoutAlgOptions","xData","yData","clusterOptions","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","algorithm","getClusteredData","destroyOldPoints","dataTable","groupedXData","groupedYData","hasGroupedData","groupMap","apply","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","isValidGroupedDataObject","k","zones","to","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","clusteredSeriesData","oldPointsId","seriesIsValidGroupedDataObject","result","seriesPreventClusterCollisions","props","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","item","projectedUnitsToPixels","MarkerClusters_MarkerClusterScatter","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","generatePoints","animateClusterPoint","plotOptions","MarkerClusters_animObject","defaultOptions","composed","MarkerClusters_addEvent","MarkerClusters_defined","MarkerClusters_error","MarkerClusters_isFunction","MarkerClusters_merge","pushUnique","MarkerClusters_syncTimeout","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","MarkerClusters_onPointDrillToCluster","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","MarkerClusterSymbols_cluster","w","h","inner","arc","space","start","PI","end","open","outer1","innerR","outerWidth","outer2","concat","G","MarkerClusters_MarkerClusters","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","scatter","ScatterSeries","types","Axis","Chart","Series","MarkerClusters_MarkerClusterSymbols","SVGRendererClass","SVGRenderer"],"mappings":"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"}